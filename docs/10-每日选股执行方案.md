# 10-每日选股执行方案

本文档提供每日选股的完整执行方案，包括手动执行和半自动脚本两种方式，帮助您实现每日自动化选股流程。

## 一、每日选股流程概述

每日选股的基本流程如下：

```
1. 更新数据 → 2. 获取最新交易日 → 3. 运行选股工具 → 4. 保存结果
```

### 执行顺序说明

1. **更新数据**：确保数据包含最新的交易日数据
2. **获取最新交易日**：获取当日交易日作为选股日期（盘后执行时，当日数据已更新完成）
3. **运行选股工具**：使用选股工具对最新交易日进行选股
4. **保存结果**：将选股结果保存到文件，便于后续使用

**注意**：本方案适用于**盘后执行**的场景。如果是盘中执行，可能需要使用前一个交易日的数据。

### 为什么需要先更新数据？

- 选股工具需要最新的市场数据才能做出准确的预测
- 如果数据不是最新的，选股结果可能基于过时的信息
- 建议每次选股前都更新数据，确保使用最新信息

## 二、方案A：手动执行步骤（简单方案）

方案A适合初学者或需要手动控制的场景，每个步骤都需要手动执行。

### 步骤1：更新数据到最新日期

在选股之前，先更新数据到最新日期：

```bash
# 更新 A 股数据
python -m qlib.cli.data qlib_data \
    --target_dir ~/.qlib/qlib_data/cn_data \
    --region cn

# 更新美股数据（如果使用）
python -m qlib.cli.data qlib_data \
    --target_dir ~/.qlib/qlib_data/us_data \
    --region us
```

**说明**：
- 数据更新可能需要几分钟时间
- 如果数据已经是最新的，更新会很快完成
- 建议在交易日收盘后更新数据

### 步骤2：获取最新交易日

创建一个 Python 脚本来获取最新交易日：

创建文件 `get_latest_trade_date.py`：

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
获取最新交易日（盘后执行时获取当日交易日）
"""

import qlib
from qlib.constant import REG_CN
from qlib.data import D
from datetime import datetime, timedelta

def get_latest_trade_date(provider_uri='~/.qlib/qlib_data/cn_data', region=REG_CN, use_today=True):
    """
    获取最新交易日

    参数:
        provider_uri: 数据路径
        region: 市场区域
        use_today: 是否使用当日交易日（True=盘后执行，False=使用前一个交易日）
    """
    # 初始化 Qlib
    qlib.init(provider_uri=provider_uri, region=region)

    # 获取最近30天的交易日历
    end_date = datetime.now().strftime('%Y-%m-%d')
    start_date = (datetime.now() - timedelta(days=30)).strftime('%Y-%m-%d')

    calendar = D.calendar(start_time=start_date, end_time=end_date)

    if len(calendar) == 0:
        print("❌ 未找到交易日")
        return None

    # 获取最后一个交易日
    latest_trade_date = calendar[-1]
    today = datetime.now().strftime('%Y-%m-%d')

    if use_today:
        # 盘后执行：如果今天是交易日，使用今天；否则使用最近的交易日
        if latest_trade_date.strftime('%Y-%m-%d') == today:
            return latest_trade_date.strftime('%Y-%m-%d')
        else:
            # 今天不是交易日，使用最近的交易日
            return latest_trade_date.strftime('%Y-%m-%d')
    else:
        # 盘中执行：使用前一个交易日
        if latest_trade_date.strftime('%Y-%m-%d') == today and len(calendar) > 1:
            latest_trade_date = calendar[-2]
        return latest_trade_date.strftime('%Y-%m-%d')

if __name__ == '__main__':
    # 盘后执行：使用当日交易日
    latest_date = get_latest_trade_date(use_today=True)
    if latest_date:
        print(f"最新交易日: {latest_date}")
    else:
        print("获取最新交易日失败")
```

运行脚本获取最新交易日：

```bash
python get_latest_trade_date.py
```

输出示例：
```
最新交易日: 2024-01-15
```

### 步骤3：运行选股工具

使用增强版选股工具进行选股。假设最新交易日是 `2024-01-15`：

#### 使用预训练模型（推荐）

```bash
python examples/06_stock_selection_cli_advanced.py \
    --provider_uri ~/.qlib/qlib_data/cn_data \
    --region cn \
    --market csi300 \
    --start_date 2024-01-15 \
    --end_date 2024-01-15 \
    --topk 10 \
    --model_path ./models/lgb_model.pkl
```

#### 使用训练新模型

```bash
python examples/06_stock_selection_cli_advanced.py \
    --provider_uri ~/.qlib/qlib_data/cn_data \
    --region cn \
    --market csi300 \
    --start_date 2024-01-15 \
    --end_date 2024-01-15 \
    --topk 10 \
    --train_start 2020-01-01 \
    --train_end 2023-12-31
```

**参数说明**：
- `--start_date` 和 `--end_date`：都设置为最新交易日
- `--topk`：选择股票数量
- `--model_path`：预训练模型路径（如果使用预训练模型）
- `--train_start` 和 `--train_end`：模型训练时间范围（如果训练新模型）

### 步骤4：查看和保存结果

选股工具会在终端输出选股结果。可以将结果保存到文件：

```bash
# 保存选股结果到文件
python examples/06_stock_selection_cli_advanced.py \
    --start_date 2024-01-15 \
    --end_date 2024-01-15 \
    --topk 10 \
    --model_path ./models/lgb_model.pkl \
    > selection_result_2024-01-15.txt
```

## 三、方案B：半自动脚本（推荐方案）

方案B使用 Python 脚本自动执行大部分步骤，只需运行一个脚本即可完成选股。

### 脚本功能

半自动脚本会自动完成：
1. 检查并更新数据（可选）
2. 获取最新交易日
3. 加载预训练模型或训练新模型
4. 运行选股工具
5. 保存结果到文件

### 脚本代码

创建文件 `daily_stock_selection.py`：

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
每日选股半自动脚本

自动完成：获取最新交易日 → 运行选股工具 → 保存结果
"""

import argparse
import sys
import os
from datetime import datetime, timedelta
import qlib
from qlib.constant import REG_CN, REG_US
from qlib.data import D
from qlib.contrib.model.gbdt import LGBModel
from qlib.data.dataset import DatasetH
from qlib.contrib.data.handler import Alpha158
import pickle


def get_latest_trade_date(provider_uri, region, use_today=True):
    """
    获取最新交易日

    参数:
        provider_uri: 数据路径
        region: 市场区域
        use_today: 是否使用当日交易日（True=盘后执行，False=使用前一个交易日）
    """
    qlib.init(provider_uri=provider_uri, region=region)

    # 获取最近30天的交易日历
    end_date = datetime.now().strftime('%Y-%m-%d')
    start_date = (datetime.now() - timedelta(days=30)).strftime('%Y-%m-%d')

    calendar = D.calendar(start_time=start_date, end_time=end_date)

    if len(calendar) == 0:
        return None

    # 获取最后一个交易日
    latest_trade_date = calendar[-1]
    today = datetime.now().strftime('%Y-%m-%d')

    if use_today:
        # 盘后执行：如果今天是交易日，使用今天；否则使用最近的交易日
        if latest_trade_date.strftime('%Y-%m-%d') == today:
            return latest_trade_date.strftime('%Y-%m-%d')
        else:
            # 今天不是交易日，使用最近的交易日
            return latest_trade_date.strftime('%Y-%m-%d')
    else:
        # 盘中执行：使用前一个交易日
        if latest_trade_date.strftime('%Y-%m-%d') == today and len(calendar) > 1:
            latest_trade_date = calendar[-2]
        return latest_trade_date.strftime('%Y-%m-%d')


def train_model(provider_uri, region, market, train_start, train_end):
    """训练模型"""
    print("正在训练模型...")

    handler = Alpha158(
        start_time=train_start,
        end_time=train_end,
        fit_start_time=train_start,
        fit_end_time=train_end,
        instruments=market
    )

    dataset = DatasetH(
        handler=handler,
        segments={
            'train': (train_start, train_end)
        }
    )

    model = LGBModel(
        loss='mse',
        learning_rate=0.05,
        num_leaves=31,
        max_depth=5,
        num_threads=20
    )

    model.fit(dataset)
    print("✅ 模型训练完成")

    return model


def run_selection(provider_uri, region, market, trade_date, topk, model, output_file=None):
    """运行选股"""
    print(f"正在对 {trade_date} 进行选股...")

    handler = Alpha158(
        start_time=trade_date,
        end_time=trade_date,
        fit_start_time=trade_date,
        fit_end_time=trade_date,
        instruments=market
    )

    dataset = DatasetH(
        handler=handler,
        segments={
            'test': (trade_date, trade_date)
        }
    )

    test_data = dataset.prepare('test')
    pred = model.predict(test_data)

    # 获取选股结果
    pred_df = pred.reset_index()
    pred_df.columns = ['instrument', 'datetime', 'score']

    # 获取当日的 Top-K
    date_data = pred_df[pred_df['datetime'] == pred_df['datetime'].iloc[0]]
    topk_stocks = date_data.sort_values('score', ascending=False).head(topk)

    # 输出结果
    result_lines = []
    result_lines.append("=" * 60)
    result_lines.append(f"选股结果 ({trade_date})")
    result_lines.append("=" * 60)
    result_lines.append(f"{'排名':<6} {'股票代码':<15} {'预测分数':<15}")
    result_lines.append("-" * 60)

    for idx, row in enumerate(topk_stocks.iterrows(), 1):
        line = f"{idx:<6} {row[1]['instrument']:<15} {row[1]['score']:>14.6f}"
        result_lines.append(line)
        print(line)

    result_lines.append("=" * 60)

    # 保存到文件
    if output_file:
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write('\n'.join(result_lines))
        print(f"\n✅ 结果已保存到: {output_file}")

    return topk_stocks


def main():
    """主函数"""
    parser = argparse.ArgumentParser(
        description='每日选股半自动脚本',
        formatter_class=argparse.RawDescriptionHelpFormatter
    )

    parser.add_argument(
        '--provider_uri',
        type=str,
        default='~/.qlib/qlib_data/cn_data',
        help='数据路径（默认: ~/.qlib/qlib_data/cn_data）'
    )
    parser.add_argument(
        '--region',
        type=str,
        choices=['cn', 'us'],
        default='cn',
        help='市场区域: cn (A股) 或 us (美股)，默认: cn'
    )
    parser.add_argument(
        '--market',
        type=str,
        default='csi300',
        help='股票池，默认: csi300'
    )
    parser.add_argument(
        '--topk',
        type=int,
        default=10,
        help='选择股票数量，默认: 10'
    )
    parser.add_argument(
        '--model_path',
        type=str,
        default=None,
        help='预训练模型路径（可选）'
    )
    parser.add_argument(
        '--train_start',
        type=str,
        default=None,
        help='模型训练开始日期（如果使用训练模式）'
    )
    parser.add_argument(
        '--train_end',
        type=str,
        default=None,
        help='模型训练结束日期（如果使用训练模式）'
    )
    parser.add_argument(
        '--output_dir',
        type=str,
        default='./selection_results',
        help='结果保存目录，默认: ./selection_results'
    )
    parser.add_argument(
        '--update_data',
        action='store_true',
        help='是否在选股前更新数据（默认: False）'
    )
    parser.add_argument(
        '--use_previous',
        action='store_true',
        help='使用前一个交易日（默认使用当日交易日，用于盘中执行）'
    )

    args = parser.parse_args()

    # 1. 更新数据（如果启用）
    if args.update_data:
        print("正在更新数据...")
        import subprocess
        region_flag = 'cn' if args.region == REG_CN else 'us'
        cmd = [
            'python', '-m', 'qlib.cli.data', 'qlib_data',
            '--target_dir', args.provider_uri,
            '--region', region_flag
        ]
        try:
            subprocess.run(cmd, check=True)
            print("✅ 数据更新完成\n")
        except Exception as e:
            print(f"⚠️ 数据更新失败: {e}\n")

    # 2. 获取最新交易日
    print("正在获取最新交易日...")
    region = REG_CN if args.region == 'cn' else REG_US
    use_today = not args.use_previous  # 默认使用当日交易日，如果指定了 --use_previous，则使用前一个交易日
    latest_date = get_latest_trade_date(args.provider_uri, region, use_today=use_today)

    if not latest_date:
        print("❌ 获取最新交易日失败")
        sys.exit(1)

    print(f"✅ 最新交易日: {latest_date}\n")

    # 3. 加载或训练模型
    model = None
    if args.model_path:
        try:
            print(f"正在加载模型: {args.model_path}")
            with open(args.model_path, 'rb') as f:
                model = pickle.load(f)
            print("✅ 模型加载成功\n")
        except Exception as e:
            print(f"❌ 模型加载失败: {e}")
            sys.exit(1)
    elif args.train_start and args.train_end:
        try:
            model = train_model(
                args.provider_uri, region, args.market,
                args.train_start, args.train_end
            )
            print()
        except Exception as e:
            print(f"❌ 模型训练失败: {e}")
            sys.exit(1)
    else:
        print("❌ 错误: 必须提供 --model_path 或 --train_start 和 --train_end")
        sys.exit(1)

    # 4. 运行选股
    os.makedirs(args.output_dir, exist_ok=True)
    output_file = os.path.join(args.output_dir, f'selection_{latest_date}.txt')

    try:
        run_selection(
            args.provider_uri, region, args.market,
            latest_date, args.topk, model, output_file
        )
        print("\n✅ 每日选股完成！")
    except Exception as e:
        print(f"❌ 选股失败: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)


if __name__ == '__main__':
    main()
```

### 使用方法

#### 使用预训练模型

```bash
python daily_stock_selection.py \
    --provider_uri ~/.qlib/qlib_data/cn_data \
    --region cn \
    --market csi300 \
    --topk 10 \
    --model_path ./models/lgb_model.pkl \
    --output_dir ./selection_results
```

#### 使用训练新模型

```bash
python daily_stock_selection.py \
    --provider_uri ~/.qlib/qlib_data/cn_data \
    --region cn \
    --market csi300 \
    --topk 10 \
    --train_start 2020-01-01 \
    --train_end 2023-12-31 \
    --output_dir ./selection_results
```

#### 自动更新数据

```bash
python daily_stock_selection.py \
    --model_path ./models/lgb_model.pkl \
    --update_data \
    --output_dir ./selection_results
```

**参数说明**：
- `--update_data`：在选股前自动更新数据
- `--output_dir`：结果保存目录，默认 `./selection_results`
- `--use_previous`：使用前一个交易日（用于盘中执行，默认使用当日交易日）
- 其他参数与选股工具相同

**执行时机说明**：
- **盘后执行**（推荐）：默认使用当日交易日，数据已更新完成
- **盘中执行**：使用 `--use_previous` 参数，使用前一个交易日的数据

## 四、模型策略选择

### 预训练模型方案

**优点**：
- 执行速度快，无需训练时间
- 模型稳定，结果可复现
- 适合每日快速选股

**缺点**：
- 模型可能过时，无法适应市场变化
- 需要定期手动更新模型

**适用场景**：
- 每日选股，追求速度
- 模型性能稳定，无需频繁调整
- 计算资源有限

**使用方法**：
```bash
# 方案A：手动执行
python examples/06_stock_selection_cli_advanced.py \
    --start_date 2024-01-15 \
    --end_date 2024-01-15 \
    --topk 10 \
    --model_path ./models/lgb_model.pkl

# 方案B：半自动脚本
python daily_stock_selection.py \
    --model_path ./models/lgb_model.pkl \
    --topk 10
```

### 每次训练方案

**优点**：
- 模型始终使用最新数据训练
- 能够适应市场变化
- 模型性能可能更好

**缺点**：
- 训练时间长，每次需要几分钟到几十分钟
- 计算资源消耗大
- 模型可能不稳定

**适用场景**：
- 有充足的计算资源
- 需要模型适应市场变化
- 不追求执行速度

**使用方法**：
```bash
# 方案A：手动执行
python examples/06_stock_selection_cli_advanced.py \
    --start_date 2024-01-15 \
    --end_date 2024-01-15 \
    --topk 10 \
    --train_start 2020-01-01 \
    --train_end 2023-12-31

# 方案B：半自动脚本
python daily_stock_selection.py \
    --train_start 2020-01-01 \
    --train_end 2023-12-31 \
    --topk 10
```

### 选择建议

1. **日常使用**：推荐使用预训练模型，速度快，稳定
2. **定期更新**：建议每周或每月重新训练一次模型
3. **重要决策**：如果需要更准确的预测，可以使用每次训练方案
4. **资源充足**：如果计算资源充足，可以使用每次训练方案

## 五、获取最新交易日的方法

### 方法说明

**盘后执行场景**（推荐）：
- 盘后执行时，当日的数据已经更新完成
- 应该使用当日交易日进行选股
- 这是最常见的每日选股场景

**盘中执行场景**（可选）：
- 如果需要在盘中执行，当日数据可能还未更新
- 可以使用前一个交易日的数据
- 通过 `use_today=False` 参数控制

### Python 代码实现

```python
import qlib
from qlib.constant import REG_CN
from qlib.data import D
from datetime import datetime, timedelta

def get_latest_trade_date(provider_uri='~/.qlib/qlib_data/cn_data', region=REG_CN, use_today=True):
    """
    获取最新交易日

    参数:
        provider_uri: 数据路径
        region: 市场区域
        use_today: 是否使用当日交易日（True=盘后执行，False=使用前一个交易日）
    """
    # 初始化 Qlib
    qlib.init(provider_uri=provider_uri, region=region)

    # 获取最近30天的交易日历
    end_date = datetime.now().strftime('%Y-%m-%d')
    start_date = (datetime.now() - timedelta(days=30)).strftime('%Y-%m-%d')

    calendar = D.calendar(start_time=start_date, end_time=end_date)

    if len(calendar) == 0:
        return None

    # 获取最后一个交易日
    latest_trade_date = calendar[-1]
    today = datetime.now().strftime('%Y-%m-%d')

    if use_today:
        # 盘后执行：如果今天是交易日，使用今天；否则使用最近的交易日
        if latest_trade_date.strftime('%Y-%m-%d') == today:
            return latest_trade_date.strftime('%Y-%m-%d')
        else:
            # 今天不是交易日，使用最近的交易日
            return latest_trade_date.strftime('%Y-%m-%d')
    else:
        # 盘中执行：使用前一个交易日
        if latest_trade_date.strftime('%Y-%m-%d') == today and len(calendar) > 1:
            latest_trade_date = calendar[-2]
        return latest_trade_date.strftime('%Y-%m-%d')

# 使用示例
# 盘后执行：使用当日交易日
latest_date = get_latest_trade_date(use_today=True)
print(f"最新交易日: {latest_date}")

# 盘中执行：使用前一个交易日
latest_date = get_latest_trade_date(use_today=False)
print(f"最新交易日: {latest_date}")
```

### 注意事项

1. **数据更新**：确保数据已更新到最新，否则可能获取不到最新交易日
2. **执行时机**：建议在盘后执行（A股下午3点后，美股下午4点后），此时当日数据已更新完成
3. **时区问题**：注意系统时区，确保日期计算正确
4. **非交易日**：如果今天是周末或节假日，会自动获取最近的交易日
5. **数据范围**：如果最近30天没有交易日，可以增加查询范围

## 六、完整示例

### 示例1：方案A完整流程（手动执行）

假设今天是 2024年1月16日（周二，盘后执行），需要选择当日交易日（1月16日）的股票：

```bash
# 步骤1：更新数据
python -m qlib.cli.data qlib_data \
    --target_dir ~/.qlib/qlib_data/cn_data \
    --region cn

# 步骤2：获取最新交易日（盘后执行，获取当日交易日）
python get_latest_trade_date.py
# 输出: 最新交易日: 2024-01-16

# 步骤3：运行选股工具
python examples/06_stock_selection_cli_advanced.py \
    --provider_uri ~/.qlib/qlib_data/cn_data \
    --region cn \
    --market csi300 \
    --start_date 2024-01-16 \
    --end_date 2024-01-16 \
    --topk 10 \
    --model_path ./models/lgb_model.pkl \
    > selection_result_2024-01-16.txt

# 步骤4：查看结果
cat selection_result_2024-01-16.txt
```

### 示例2：方案B完整流程（脚本执行）

```bash
# 一键执行（自动更新数据 + 自动获取最新交易日 + 自动选股 + 自动保存）
python daily_stock_selection.py \
    --provider_uri ~/.qlib/qlib_data/cn_data \
    --region cn \
    --market csi300 \
    --topk 10 \
    --model_path ./models/lgb_model.pkl \
    --update_data \
    --output_dir ./selection_results
```

执行后会自动：
1. 更新数据到最新
2. 获取最新交易日（盘后执行时，如 2024-01-16）
3. 加载模型
4. 进行选股
5. 保存结果到 `./selection_results/selection_2024-01-16.txt`

## 七、常见问题

### 问题1：数据更新失败

**错误信息**：
```
ConnectionError: Failed to download data
```

**解决方案**：
1. 检查网络连接
2. 稍后重试
3. 如果持续失败，可以跳过更新，使用现有数据

### 问题2：获取不到最新交易日

**错误信息**：
```
未找到交易日
```

**解决方案**：
1. 检查数据是否已更新
2. 检查日期范围是否足够（可以增加查询天数）
3. 确认数据路径是否正确

### 问题3：选股工具执行失败

**错误信息**：
```
❌ 生成预测信号失败
```

**解决方案**：
1. 检查数据是否包含指定日期的数据
2. 检查模型文件是否存在且正确
3. 检查股票池是否正确

### 问题4：模型加载失败

**错误信息**：
```
FileNotFoundError: Model file not found
```

**解决方案**：
1. 检查模型路径是否正确
2. 确认模型文件是否存在
3. 或者使用 `--train_start` 和 `--train_end` 训练新模型

### 问题5：结果文件保存失败

**解决方案**：
1. 检查输出目录是否有写入权限
2. 确认磁盘空间是否充足
3. 检查文件路径是否正确

## 八、进阶：定时自动化（可选）

如果需要完全自动化，可以使用 crontab 定时执行。

### 设置定时任务

```bash
# 编辑 crontab
crontab -e

# 添加每日选股任务（每天下午3点执行，股市收盘后）
0 15 * * 1-5 cd /path/to/qliblearner && python daily_stock_selection.py --model_path ./models/lgb_model.pkl --update_data --output_dir ./selection_results >> ./logs/daily_selection.log 2>&1
```

**说明**：
- `0 15 * * 1-5`：周一到周五下午3点执行
- `cd /path/to/qliblearner`：切换到项目目录
- `>> ./logs/daily_selection.log 2>&1`：将输出保存到日志文件

### 注意事项

1. **执行时间**：建议在股市收盘后执行（A股下午3点，美股下午4点）
2. **日志记录**：建议保存日志，便于排查问题
3. **错误处理**：脚本应该包含错误处理，避免因小错误导致任务失败
4. **通知机制**：可以添加邮件或消息通知，及时了解执行结果

## 九、下一步

掌握每日选股执行方案后，您可以：

- 根据实际需求选择方案A或方案B
- 根据资源情况选择模型策略
- 设置定时任务实现完全自动化
- 根据选股结果进行实际投资决策（注意：本工具仅用于学习，投资需谨慎）

## 十、相关文档

- **[02-数据准备.md](02-数据准备.md)** - 数据下载和更新方法
- **[08-命令行选股工具.md](08-命令行选股工具.md)** - 选股工具详细说明
- **[05-模型训练.md](05-模型训练.md)** - 模型训练方法
- **[07-选股策略.md](07-选股策略.md)** - 选股策略详解

## 十一、执行检查清单

在开始每日选股之前，请确认：

- [ ] 已安装 Qlib 和相关依赖
- [ ] 已下载数据（A股或美股）
- [ ] 已准备好模型文件（如果使用预训练模型）
- [ ] 理解方案A和方案B的区别
- [ ] 知道如何获取最新交易日
- [ ] 了解模型策略的选择

如果所有项目都已完成，您可以开始执行每日选股了！
